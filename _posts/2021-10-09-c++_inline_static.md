---
    author: xiao.liang
    date  : 2021-10-09
    title : "Inline and Static Functions in C++"
    categories:
        - C++
    tags: C++
---

## inline与内敛优化

关于inline关键字，很早之前学习C++的时候就总是说，如果你想要优化一个函数，那么将它标识为inline，并且将实现也放到头文件中，这样编译器会决定是否要对该函数进行编译优化。

这种说法可以说对，也可以说不对。

对是因为你想要函数被内敛优化确实需要添加inline关键字；不对的地方在于它生效的机制并不是因为需要通过inline关键字来告诉编译器我需要内敛优化这个函数。

实际上，当前的编译器决定是否内联函数的时候，可以说是完全不看inline关键字了。inline关键字最重要的用法，是告诉编译器函数的定义放在那里。

基础的编译知识告诉我们如下几个事实

1. 一个函数如果是写在一个.cpp文件里，那你永远不需要写inline关键字，因为编译器是按照翻译单元进行独立编译的，写在.cpp文件里的内容永远无法被其它翻译单元所看到
2. 如果想要某个函数被内敛优化，那么它必须被**定义**在头文件中，这样其它翻译单元在include该头文件时才能拿到完整的函数实现，因此才能进行内敛优化（除非相关函数都在同一个.cpp中）
3. 如果直接把函数的**定义**写在头文件里或类的**定义**之外，那一旦有多个文件包含这个头文件，链接就会出错，因为C++对于普通的函数和变量都只允许你**定义**一次。为了解决这个问题，必须添加inline或者static关键字

> Note: 注意声明(declaration)和定义(definition)的区别

基于上述事实，我们可以得到如下的结论：

**如果你希望某个函数被内敛优化，那么首先你需要让编译器能看到它的定义（即把函数定义放到头文件中），然后通过链接检查（针对普通函数添加inline关键字）**

当然，内敛优化还是应该针对简单的小函数来使用，针对大函数这么干一没用，二还减慢编译速度。

ref: https://www.zhihu.com/question/452546506/answer/1814780620


## static & inline

上一小节我们说到，要解决同名函数的链接问题，可以通过给函数添加inline或static关键字来解决

实际上，这两者的实现机理仍然有一定的差别

**static**，会让编译器为每一个翻译单元生成一个属于自己的函数实现副本，同时链接器会让每个翻译单元使用自身的函数副本。因此在不同的翻译单元对该函数进行取址，会获得不同的地址

**inline**，告诉编译器对该函数践行ODR（One Definition Rule），此时在编译期，每个翻译单元也会生成一个属于自己的函数副本，但是在链接期，链接器会决定是否需要内敛优化，还是合并相同的函数副本。如果某个翻译单元需要内敛优化，那么会保留自己的函数副本。也就是说，如果不产生任何内敛优化的情况下，最后只会保留一个函数副本，所有的翻译单元共享这个函数副本。

## 总结
不管三七二十一，我们可以总结如下现代C++的惯用法

1. 当某个函数可能会在多个翻译单元出现时，使用inline关键字来替代static关键字来解决链接问题
2. 对于那些你想要编译器进行内敛优化的普通函数，将它的定义写在头文件中，并且使用inline关键字标识。而对于成员函数，直接将定义写在头文件即可